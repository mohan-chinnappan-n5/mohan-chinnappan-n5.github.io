<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Admin Tools</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduciton.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="admin-changes-app.html"><strong aria-hidden="true">2.</strong> Admin Changes App</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Admin Tools</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this book, we discuss about the admin tools for Salesforce Administrator. This book is a companion to the <a href="https://mohan-chinnappan-n5.github.io/sfbooks/sfdevnotes/index.html">Salesforce Development Notes</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="admin-changes-implementor-app"><a class="header" href="#admin-changes-implementor-app">Admin changes implementor App</a></h1>
<p><img src="img/admin-chages-app-1.png" alt="admin-changes tool" /></p>
<p>The App is  designed to handle administrative configuration changes in a Salesforce environment and automate the process of tracking, converting, and deploying these changes using version control and pipelines. The process begins with either an admin or designer user making configuration changes in a copy of the production environment and then moves towards generating metadata for deployment. This app can handle changes in two different ways, presented as <strong>Option 1</strong> and <strong>Option 2</strong> in the flowchart.</p>
<h3 id="overview-of-the-app"><a class="header" href="#overview-of-the-app"><strong>Overview of the App</strong></a></h3>
<p>The app revolves around automating the retrieval, packaging, and deployment of changes made in a Salesforce production copy. The process ensures that any configuration changes made by admin or designer users are properly tracked and deployed to other environments through version control systems and pipelines. The app uses Salesforce's Metadata API to generate the necessary files for deployment, and then those files are committed to a Git repository for versioning and further deployment.</p>
<h4 id="main-components-of-the-application"><a class="header" href="#main-components-of-the-application"><strong>Main Components of the Application:</strong></a></h4>
<ol>
<li>
<p><strong>Admin/Designer User</strong>: The admin or designer users are responsible for making configuration changes in a Salesforce sandbox, which is a copy of the production environment.</p>
</li>
<li>
<p><strong>Production Copy</strong>: A clone of the production environment where the actual changes are made. This could be a sandbox or staging environment where the modifications are tested before moving into production.</p>
</li>
<li>
<p><strong>Options for Change Tracking</strong>:</p>
<ul>
<li><strong>Option 1</strong>: Admin or designer users manually keep track of the changes they made. This includes tracking the asset name (e.g., <code>Amount2__c</code>) and asset type (e.g., <code>CustomField</code>).</li>
<li><strong>Option 2</strong>: The system automatically retrieves a list of changes using Salesforce’s Tooling API, particularly the <code>SourceMember</code> object, which can capture changes to metadata such as fields, objects, and layouts.</li>
</ul>
</li>
<li>
<p><strong>package.xml Generator</strong>: This component generates the <code>package.xml</code> file, which is required for Salesforce Metadata API deployment. The <code>package.xml</code> file lists the metadata types and components that need to be retrieved, converted, or deployed.</p>
</li>
<li>
<p><strong>Metadata Conversion (sf force mdapi convert)</strong>: The changes listed in the <code>package.xml</code> file are converted using Salesforce's command-line interface (CLI), specifically the <code>mdapi convert</code> command, which transforms metadata into a deployable source format.</p>
</li>
<li>
<p><strong>Git Committer</strong>: Once the metadata is converted, the changes are committed to a Git repository, ensuring version control and enabling collaborative workflows.</p>
</li>
<li>
<p><strong>Pipelines</strong>: The changes are pushed through deployment pipelines that handle the movement of code and metadata to main orgs (like ST).</p>
</li>
</ol>
<h3 id="option-1-manual-tracking-of-changes"><a class="header" href="#option-1-manual-tracking-of-changes"><strong>Option 1: Manual Tracking of Changes</strong></a></h3>
<p>In <strong>Option 1</strong>, admin or designer users are responsible for manually keeping a list of the changes they made. For each change, they would note down:</p>
<ul>
<li><strong>Asset Name</strong>: The name of the metadata component that was changed, such as a custom field (<code>Amount2__c</code>).</li>
<li><strong>Asset Type</strong>: The type of metadata component, such as <code>CustomField</code>, <code>CustomObject</code>, etc.</li>
</ul>
<p>Once the list of changes is compiled, it is passed into the <code>package.xml</code> generator, which creates a deployment package based on the changes the user tracked. From here, the changes are converted, committed to Git, and pushed through the deployment pipeline.</p>
<h4 id="pros-of-option-1"><a class="header" href="#pros-of-option-1"><strong>Pros of Option 1</strong>:</a></h4>
<ol>
<li><strong>More Control</strong>: Users have complete control over which changes they want to track and deploy. This is particularly useful when only a subset of changes needs to be deployed to production.</li>
<li><strong>Less Overhead</strong>: If there are only a few changes, the process can be quicker, as the user only tracks the relevant modifications.</li>
<li><strong>Selective Deployment</strong>: Users can choose specific changes to be packaged and deployed, allowing for more targeted updates.</li>
</ol>
<h4 id="cons-of-option-1"><a class="header" href="#cons-of-option-1"><strong>Cons of Option 1</strong>:</a></h4>
<ol>
<li><strong>Human Error</strong>: Since this process relies on manual tracking, there is a higher chance of missing important changes or including unnecessary ones.</li>
<li><strong>Time-Consuming</strong>: Manually tracking changes can be tedious, especially when multiple or complex modifications are made across different metadata components.</li>
<li><strong>Less Automation</strong>: This method lacks the automation provided by Option 2, meaning there is more room for oversight and delays.</li>
</ol>
<h3 id="option-2-automated-change-tracking-using-the-tooling-api"><a class="header" href="#option-2-automated-change-tracking-using-the-tooling-api"><strong>Option 2: Automated Change Tracking Using the Tooling API</strong></a></h3>
<p>In <strong>Option 2</strong>, the system uses Salesforce’s Tooling API, specifically the <code>SourceMember</code> object, to automatically detect and retrieve the list of changes made in the production copy. The Tooling API provides detailed information about the metadata changes, making this process more automated.</p>
<p>The changes retrieved via the Tooling API are fed into the <code>package.xml</code> generator, and the process continues with metadata conversion, Git commits, and deployment through pipelines.</p>
<h4 id="pros-of-option-2"><a class="header" href="#pros-of-option-2"><strong>Pros of Option 2</strong>:</a></h4>
<ol>
<li><strong>Automation</strong>: This option eliminates the need for manual tracking of changes, reducing the possibility of human error.</li>
<li><strong>Time-Saving</strong>: Automated tracking is faster, especially when there are many changes to process, as the Tooling API can quickly gather all the modifications.</li>
<li><strong>Accuracy</strong>: Since the system is responsible for tracking changes, there is less chance of missing any updates, ensuring that all relevant metadata changes are included.</li>
<li><strong>Consistency</strong>: This method ensures that all changes are captured uniformly, reducing discrepancies in the deployment process.</li>
</ol>
<h4 id="cons-of-option-2"><a class="header" href="#cons-of-option-2"><strong>Cons of Option 2</strong>:</a></h4>
<ol>
<li><strong>Overhead</strong>: Automatically tracking all changes may result in more metadata being captured than necessary. In some cases, the user might only want to deploy specific changes, and additional steps may be required to exclude irrelevant ones.</li>
<li><strong>Dependency on API</strong>: This method is dependent on the Salesforce Tooling API. If there are issues with the API or limitations in retrieving certain metadata types, the process could be interrupted or incomplete.</li>
<li><strong>Complexity</strong>: The automation process can be more complex to set up initially, especially if specific filters or configurations are needed to capture only the desired changes.</li>
</ol>
<h3 id="packagexml-generator-and-metadata-conversion"><a class="header" href="#packagexml-generator-and-metadata-conversion"><strong>package.xml Generator and Metadata Conversion</strong></a></h3>
<p>In both options, the app generates a <code>package.xml</code> file based on the changes tracked (either manually in Option 1 or automatically in Option 2). The <code>package.xml</code> file serves as a blueprint for the metadata that needs to be deployed. The app then uses the Salesforce CLI to convert these changes into the appropriate format using the <code>sf force mdapi convert</code> command.</p>
<h3 id="git-committer-and-pipelines"><a class="header" href="#git-committer-and-pipelines"><strong>Git Committer and Pipelines</strong></a></h3>
<p>After the metadata is converted, the app commits the changes to a Git repository. This ensures that the metadata changes are version-controlled and can be tracked or rolled back if needed. The changes are then pushed through deployment pipelines, which handle the process of deploying the changes to various environments (e.g., testing, staging, or production).</p>
<h3 id="conclusion"><a class="header" href="#conclusion"><strong>Conclusion</strong></a></h3>
<p>This app provides a flexible approach to tracking and deploying Salesforce configuration changes. Both <strong>Option 1</strong> and <strong>Option 2</strong> have their own use cases, and the choice between them depends on the specific requirements of the deployment process.</p>
<ul>
<li><strong>Option 1</strong> offers more control and flexibility but requires manual effort, making it more prone to human error.</li>
<li><strong>Option 2</strong> is more automated and efficient, ensuring that all changes are captured, but it may introduce additional overhead by including unnecessary changes.
<ul>
<li>
<p>The API used in this option is now changed to <a href="https://developer.salesforce.com/docs/atlas.en-us.api_tooling.meta/api_tooling/tooling_api_objects_sourcemember.htm"><strong>internal use only</strong></a></p>
</li>
<li>
<p><img src="img/sourceMember.png" alt="sourcemember" /></p>
</li>
<li>
<p>This makes option-2 unsupportable.</p>
</li>
</ul>
</li>
</ul>
<p>In environments where changes are frequent and complex, <strong>Option 2</strong> would likely be the preferred approach due to its automation and accuracy. However, for smaller teams or specific, targeted deployments, <strong>Option 1</strong> offers a simpler and more controlled process.</p>
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<video controls>
  <source src="https://github.com/mohan-chinnappan-n5/demos-git/raw/refs/heads/main/admin-changes/admin-chages-app-demo3.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
